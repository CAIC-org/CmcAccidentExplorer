<!DOCTYPE html>
<html>
<head>
	
	<title>CAIC Accident Explorer</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="images/blue_snow_icon.ico" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
	
		<!-- Loading Leaflet Omnivore to read CSV file -->
	<script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js'></script>
  <!-- Loading Leaflet heatmap plugin -->
	<script src='https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-heat/v0.1.3/leaflet-heat.js'></script>
	
		<!-- Loading fontawesome -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css"/>
	
	<!-- Loading Leaflet EasyButton -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
	<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>
	
	<!-- Loading jquery, moment.js, and daterangepicker -->
	<script type="text/javascript" src="https://cdn.jsdelivr.net/jquery/latest/jquery.min.js"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
	<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
	
	<!-- Loading chart.js -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


	<style>
		@import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700&family=Raleway&display=swap');
		html, body {
			height: 100%;
			margin: 0;
		}
				
		#container {
			display: flex;
			flex-direction: row;
			height: 100%;
		}
 
							
		#map {
			width: 60%;
			min-height: 100%;
			font-family: 'Nanum Gothic', sans-serif; 
		}

		.info { padding: 6px 8px; font: 14px/16px, 'Nanum Gothic', Arial, Helvetica, sans-serif;  
			background-color: rgba(239, 240, 250, 0.875); box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); border-radius: 5px; } 
		.info h4 { margin: 0 0 5px; color: #777; }
		.legend { text-align: left; line-height: 18px; color: rgb(147, 139, 139); } 
		.legend i { width: 18px; height: 18px; float: left; margin-right: 0px; opacity: 0.7; }
		.leaflet-popup-content-wrapper, .leaflet-popup.tip {
			background-color: #eff0fadf;
			padding: 4px;
			border-radius: 5px;
			}

		#side-panel {
			width: 40%;
			height: 100%;
			overflow: auto;
			background-color: rgb(160, 161, 165);
		}
		#chart-area, #chart-travel, #chart-rose, #chart-something {
			padding: 5px;
			margin: 5px;
			border-radius: 5px;
			background-color: #eff0fadf;
			border: 1px solid rgba(57, 57, 70, 0.875);
		}
		
		#bar-chart,#barChartCanvas, #rose, #something {
			height: 250px;
		}
		
		#reportrange {
			background: #fff;
			cursor: pointer; 
		    font-family: Nanum Gothic;
			font-size: 12px;
			text-align: center;
			margin-left: 80px;
			margin-top: 10px;
			padding: 5px 10px;
			border: 1px solid #ccc;
			position: relative;
			width: 200px;
			z-index:1000;
		}
		@media (max-width: 767px) {
			.page-switch-icon {
				display: block;
			}
		}

		/* When the browser is 820px or less */
		@media (max-width: 820px) {
			.col-sm-8>.tooltip {
				display: none !important;
			}
			#container {
				background-color: pink;
				flex-direction: column;
				width: 100%;
				min-height: 50%;
			}
			#map {
				width: 100%;
				min-height: 60%;
			}
			#side-panel {
				width: 100%;
				min-height: 40%;
			}
		}
	</style>
	
</head>
<body>	
	<div id='container'>
		<div id='map'>
			<div id="reportrange">
			    <i class="fa fa-calendar"></i>&nbsp;
			    <span></span> <i class="fa fa-caret-down"></i>
		    </div>
    	</div>
		<div id='side-panel'>
			<div id='chart-container'>
				<div id='chart-travel'><canvas id="barChartCanvas"></canvas></div>
				<div id="chart-area" ><canvas id="bar-chart" ></canvas></div>
				<div id="chart-rose"><canvas id="rose"></canvas></div>
				<div id="chart-something"><canvas id="something"></canvas></div>
			</div>
		</div>
	</div>
	
	<script type="text/javascript" src="zones.js"></script>
	<script type="text/javascript">
	
	var map = L.map('map').setView([39.118413163683854, -106.44565988833477], 7.5);
	
	var Esri_WorldTerrain = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}', {
		attribution: 'Tiles &copy; Esri &mdash; Source: Esri',
		maxZoom: 13
	}).addTo(map);
	
	var Natural_Atlas = L.tileLayer(
		'https://a-naturalatlas-tiles.global.ssl.fastly.net/topo/{z}/{x}/{y}/t@2x.jpg', {
		attribution: 'Tiles &copy; <a href="https://naturalatlas.com/"> Natural Atlas </a>',
		maxZoom: 15
		})
	
	var Stamen_Terrain = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.{ext}', {
		attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
		subdomains: 'abcd',
		minZoom: 0,
		maxZoom: 15,
		ext: 'png'
	})
	
	var imagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
		attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
	});
		
	var lGrey = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {
		attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
		subdomains: 'abcd',
		minZoom: 0,
		maxZoom: 20,
		ext: 'png'
	});
	
	var osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });
	
	
	//Zoom settings for home button
	var home = {
		lat: 39.118413163683854,
		lng: -106.44565988833477,
		zoom: 7.5
		}; 
				
	//Adds home button to map
	L.easyButton('fa fa-home',function(btn,map){
		map.setView([home.lat, home.lng], home.zoom);
		},'Zoom To Home').addTo(map);
	
	//Button to clear map filters
	L.easyButton('fa fa-filter-circle-xmark',function(btn,map){
		
		actSelected = 0;
		monthSelected = 0;
		
		var hasAcc = map.hasLayer(acc);
		var hasAccByType = map.hasLayer(accByType);
		var hasZones = map.hasLayer(zones);
		var hasHeat = map.hasLayer(heat);
			
		map.removeLayer(acc);
		map.removeLayer(accByType);
		map.removeLayer(zones);
		map.removeLayer(heat);
		
		var styleLayer = L.geoJson(null, {
					pointToLayer: function(geoJsonPoint, latlng) {
					return L.circleMarker(latlng);},
					onEachFeature: onEachFeature,
					style:style,
					filter: dateFilter
		});
		//Need to remove the acc layer from the layer control to add in the filtered version
		layerControl.removeLayer(acc);
		layerControl.removeLayer(accByType);
		layerControl.removeLayer(zones);
		layerControl.removeLayer(heat);

		acc = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayer)
		accByType = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayerByAccType);
		heat = createHeatmap(map, accPoints);
		
		if (hasAcc == true){acc.addTo(map)};
		if (hasAccByType == true){accByType.addTo(map)};
		if (hasZones == true){zones.addTo(map)};
		if (hasHeat == true){heat.addTo(map)};
		
		//Adding back in these layer controls in the correct order
		layerControl.addOverlay(acc, "Accidents");
		layerControl.addOverlay(accByType, "Accidents by Travel Mode");
		layerControl.addOverlay(zones, "Forecast Zones");
		addHeatToOverlays();
		
		barLabels.length=0;
		barChartDates.length=0;
		updateActivityChart();
		processBarChartDates();
		$('#reportrange').data('daterangepicker').startDate=moment().subtract(15, 'year');
		$('#reportrange').data('daterangepicker').endDate=moment();
		updateDisplayedDateRange(moment().subtract(15, 'year'), moment());
		},'Clear Filters').addTo(map);
		
	
	//Get style color by Dscale
	function getColor(d) {
		return d < 1.5 ?  '#ffff00' :
				d < 2  ? '#ffe800' :
				d < 2.5  ? '#ffd000' :
				d < 3  ? '#ffb800':
				d < 3.5 ? '#ff9f00':
				d < 4 ? '#ff8400':
				d < 4.5 ? '#ff6700':
				d < 5 ? '#ff4500':
				d < 999 ? '#ff0000':
						 '#ffffff';
	};


	//Get radius by Rscale
	function getSize(d) {
		return d < 1.5 ?  6 :
				d < 2  ? 6 :
				d < 2.5  ? 7 :
				d < 3  ? 7:
				d < 3.5 ? 8:
				d < 4 ? 8:
				d < 4.5 ? 9:
				d < 5 ? 9:
				d < 999 ? 10:
						 6;
	};

	//Set up ivon variable to be used for accident travel modes
	var activityIcon = L.Icon.extend({
		options: {
			iconSize:     [27, 27],
			shadowSize:   [0, 0],
			iconAnchor:   [13.5, 13.5],
			shadowAnchor: [0, 0],
			popupAnchor:  [0, 0],
		}
	})

	//define each icon image for accident travel modes
	var skiIcon = new activityIcon({iconUrl: 'images/ski_icon.svg'}),
		footIcon = new activityIcon({iconUrl: 'images/foot_icon.svg'}),
		snowboardIcon = new activityIcon({iconUrl: 'images/ski_icon.svg'}),
		snowmobileIcon = new activityIcon({iconUrl: 'images/snowmobile_icon.svg'}),
		snowshoeIcon = new activityIcon({iconUrl: 'images/snowshoe_icon.svg'}),
		otherIcon = new activityIcon({iconUrl: 'images/other_icon.svg'});

	//Get style icon by accident activity (travel mode)
	function getIcon(feature) {
		var icon;
		if (feature.properties.acc_travel_mode == "Foot") icon = footIcon;
		else if (feature.properties.acc_travel_mode == "Ski") icon = skiIcon;
		else if (feature.properties.acc_travel_mode == "Snowboard") icon = snowboardIcon;
		else if (feature.properties.acc_travel_mode == "Snowmobile") icon = snowmobileIcon;
		else if (feature.properties.acc_travel_mode == "Snowshoe") icon = snowshoeIcon;
		else icon = otherIcon;

		return icon;
	}
	
	//Basic style for accident points
	function style(feature) {
		return {
			radius: getSize(feature.properties.Rscale),
			weight: 1.5,
			opacity: 1,
			color: 'white',
			dashArray: '',
			fillOpacity: 0.8,
			//Below is to set the color by a variable, in this case by Dscale)
			fillColor: getColor(feature.properties.Dscale)
		};
	}

	//Basic style for accident points BY TRAVEL MODE
	function styleAccidentType(feature) {
	}

	//Basic style for Avalanche Forecast Zones
	function styleForecastZones(feature) {
		return {
			weight: 1.5,
			opacity: 1,
			color: 'black',
			fillOpacity: 0.5,
			fillColor: 'grey',
		};
	}

	//Style of accident points upon cursor hover
	function highlightFeature(e) {
		var layer = e.target;

		layer.setStyle({
			weight: 3,
			color: '#666',
			dashArray: '',
			fillOpacity: 0.7
		});

		if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
			layer.bringToFront();
		}
	}

	//Style of forecast zones upon cursor hover
	function highlightZone(e) {
		var zone = e.target;

		zone.setStyle({
			weight: 2,
			color: '#FFFFFF',
			dashArray: '',
			fillOpacity: 0.7
		});
	}


	function resetHighlight(e) {
		acc.resetStyle(e.target);
	}

	function resetHighlightTravelMode(e) {
		accByType.resetStyle(e.target);
	}


	//Actions for mouseover, mouseout
	function resetZone(e) {
		zones.resetStyle(e.target);
	}

	//Actions for mouseover, mouseout for accident points
	function onEachFeature(feature, layer) {
		layer.on({
			mouseover: highlightFeature,
			mouseout: resetHighlight
		});

		//content of tool tip
		layer.bindTooltip(feature.properties.acc_location + "<br>" + (moment(feature.properties.acc_date, ["DD-MMM-YY"]).format("MM/DD/YYYY")) +
			"<br>" + feature.properties.acc_activity + "<br>Caught: " + feature.properties.acc_no_caught + 
			", Buried: " + feature.properties.acc_no_buried + ", Killed: " + feature.properties.acc_no_killed);

		//content of the popup
		layer.bindPopup("<strong>" + feature.properties.acc_location +"</strong><br>" + (moment(feature.properties.acc_date, ["DD-MMM-YY"]).format("MM/DD/YYYY")) +
			"<br>" + feature.properties.acc_activity 
			+ "<br>R" + feature.properties.Rscale + " D" + feature.properties.Dscale +
			"<br>Caught: " + feature.properties.acc_no_caught + 
			", Buried: " + feature.properties.acc_no_buried + ", Killed: " + feature.properties.acc_no_killed + 
			"<br><a href=" + feature.properties.report + " target=_blank>Link to Report</a>");
			
		//Pushing the acc_activity to the bar graph
		barLabels.push(feature.properties.acc_activity);
		/* use moment to get the month and push to bar chart */
		barChartDates.push(moment(feature.properties.acc_date, ["DD-MMM-YY"]).format("MMM"));
	}

	//Actions for mouseover, mouseout for accident points BY TRAVEL MODE
	function onEachFeatureTravelMode(feature, layer) {
		layer.on({
			//mouseover: highlightFeature,
			//mouseout: resetHighlightTravelMode
		});

		//content of tool tip
		layer.bindTooltip(feature.properties.acc_location + "<br>" + (moment(feature.properties.acc_date, ["DD-MMM-YY"]).format("MM/DD/YYYY")) +
			"<br>" + feature.properties.acc_activity + "<br>Caught: " + feature.properties.acc_no_caught + 
			", Buried: " + feature.properties.acc_no_buried + ", Killed: " + feature.properties.acc_no_killed);

		//content of the popup
		layer.bindPopup("<strong>" + feature.properties.acc_location +"</strong><br>" + (moment(feature.properties.acc_date, ["DD-MMM-YY"]).format("MM/DD/YYYY")) +
			"<br>" + feature.properties.acc_activity 
			+ "<br>R" + feature.properties.Rscale + " D" + feature.properties.Dscale +
			"<br>Caught: " + feature.properties.acc_no_caught + 
			", Buried: " + feature.properties.acc_no_buried + ", Killed: " + feature.properties.acc_no_killed + 
			"<br><a href=" + feature.properties.report + " target=_blank>Link to Report</a>");
			
		//get icon for activity
		layer.setIcon(getIcon(feature));
	}


	//Actions for mouseover, mouseout for forecast zones
	function onEachZone(feature, layer) {
		layer.on({
			mouseover: highlightZone,
			mouseout: resetZone,
			'add': function(){
        			layer.bringToBack()
      			}
		});

		//content of the popup
		layer.bindPopup("<strong>" + feature.properties.name +"</strong><br>");
		
	}
	
	
	//Starting dateFilter: all accidents included
	function dateFilter(feature) {
		return true
		}


	// Create blank style geoJSON holder for CSV data
	var styleLayer = L.geoJson(null, {
		pointToLayer: function(geoJsonPoint, latlng) {
                        return L.circleMarker(latlng);},
						onEachFeature: onEachFeature,
						style:style,
						filter: dateFilter
	});

	// Create blank style geoJSON holder for CSV data BY ACC TRAVEL TYPE
	var styleLayerByAccType = L.geoJson(null, {
		pointToLayer: function(geoJsonPoint, latlng) {
                        return L.marker(latlng);},
						onEachFeature: onEachFeatureTravelMode,
						style: styleAccidentType,
						//filter: dateFilter
						//icon: skiIcon
	});


	// Create geoJSON layer 
	var zones = L.geoJson(forecastZones, {
		style: styleForecastZones,
		onEachFeature: onEachZone
	});
	
	// Adding CSV from github (made repository public). Cross-Origin Request error if loaded locally.
	var acc = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayer).addTo(map);
	var accByType = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayerByAccType);

	//define csv url
	const url = 'https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv';

	var baseLayers = {
    "Esri Terrain": Esri_WorldTerrain,
	"Stamen Terrain": Stamen_Terrain,
	"Imagery": imagery,
	"Light Grey": lGrey,
	"Open Street Map": osm,
	"Natural Atlas": Natural_Atlas,
	};

	var overlays = {
		"Accidents": acc,
		"Accidents by Travel Mode": accByType,
		"Forecast Zones": zones,
	};

	//set heat as a global var
	var heat;

	//Create heatmap layer -- need to wait for call to CSV online
	//Function to call L.heatLayer
	function createHeatmap(map, points, minDate, maxDate) {
		const pointsNoDates = [];

		//check if the date picker has been used
		if ((minDate != undefined) && (maxDate != undefined)) {
			for (i in points) {
				const pointDate = moment(points[i][2],'DD-MMM-YY');
				if ((pointDate >= minDate) && (pointDate < maxDate))  {
					pointsNoDates.push([points[i][0], points[i][1]]);
				}
			}
		} else {
			for (i in points) {
				pointsNoDates.push([points[i][0], points[i][1]]);
			}
		}
		return L.heatLayer(pointsNoDates, {
			radius: 21,
			blur: 12,
			minOpacity: 0.4,
			gradient: {.3: 'cyan', 0.7: 'blue', .98: 'purple'},
			maxZoom: 25
		});
	};
	
	function createHeatmapActivity(map, points, activity, minDate, maxDate) {
		const pointsActivity = [];
		//check if activity matches 
		for (i in points) {
			const pointActivity = points[i][3];
			const pointDate = moment(points[i][2],'DD-MMM-YY');
			if ((pointActivity == activity) && (pointDate >= minDate) && (pointDate < maxDate))  {
				pointsActivity.push([points[i][0], points[i][1]]);	
				}
			} 
		return L.heatLayer(pointsActivity, {
			radius: 21,
			blur: 12,
			minOpacity: 0.4,
			gradient: {.3: 'cyan', 0.7: 'blue', .98: 'purple'},
			maxZoom: 25
		});
	};
	
	function createHeatmapMonth(map, points, month, minDate, maxDate) {
		const pointsMonth = [];
		//check if month matches 
		for (i in points) {
			const pointMonth = moment(points[i][2],['DD-MMM-YY']).format("MMM");
			const pointDate = moment(points[i][2],'DD-MMM-YY');
			if ((pointMonth == month) && (pointDate >= minDate) && (pointDate < maxDate))  {
				pointsMonth.push([points[i][0], points[i][1]]);	
				}
			} 
		return L.heatLayer(pointsMonth, {
			radius: 21,
			blur: 12,
			minOpacity: 0.4,
			gradient: {.3: 'cyan', 0.7: 'blue', .98: 'purple'},
			maxZoom: 25
		});
	};

	//function to parse csv from url
	function parseCSV(url) {
		return fetch(url)
			.then(response => response.text())
			.then(csv => {
				const rows = csv.split("\n");
				const points = [];

				for (const row of rows) {
					const values = row.split(",");
					const lat = parseFloat(values[4]);
					const lon = parseFloat(values[5]);
					const csvDate = values[6];
					const activ = values[7];
					if (!isNaN(lat) && !isNaN(lon)) {
						points.push([lat, lon, csvDate, activ]);
					}
				}
				
				return points;
			})
	};
	
	
	//needed to set the layerControl as a variable so we can call it in
	//later filter function for dates
	const layerControl = L.control.layers(baseLayers, overlays, {collapsed: false});
	
	//function to add control layers to map
	function addControlLayersToMap(baseLayers, overlays, map) {
		layerControl.addOverlay(heat, "Heatmap");
		layerControl.addTo(map);
	}

	//add heat to overlays - wait for map to be created/data processing then create overlays
	function addHeatToOverlays() {
		if (heat!==undefined) {
			overlays["Heatmap"] = heat;
			addControlLayersToMap(baseLayers, overlays, map);
		}
		else {
			setTimeout(addHeatToOverlays, 50);
		}
	}

	//call functions
	//parse csv, create heatmap, assign var
	var accPoints = [];

	parseCSV(url).then(function(points) {
		accPoints = points;
		heat = createHeatmap(map, accPoints);
	});

	addHeatToOverlays();
	/* L.control.layers(baseLayers, overlays, {collapsed: false}).addTo(map); */
	
	
	// once the dates are selected, format and display the range in the date selection box.
	function updateDisplayedDateRange (start, end) {
			$('#reportrange span').html(start.format('MMM D, YYYY') + ' - ' + end.format('MMM D, YYYY'));
		}
	
	//Sets the dropdowns and ranges for the date range picker
	$('#reportrange').daterangepicker({
		"showDropdowns": false,
		"startDate": moment().subtract(15, 'year'),
		"endDate": moment(),
		ranges: {
				'Last 7 Days': [moment().subtract(6, 'days'), moment()],
				'Last 30 Days': [moment().subtract(29, 'days'), moment()],
				'Last Year': [moment().subtract(365, 'days'), moment()],
				'Last 2 Years': [moment().subtract(2, 'years'), moment()],
				'Last 5 Years': [moment().subtract(5, 'years'), moment()],
				'Last 10 Years': [moment().subtract(10, 'years'), moment()],
				'All': [moment().subtract(15, 'years'), moment()],
				},
				maxDate: moment()
		}, updateDisplayedDateRange,
	);
	
	//Sets the initial dates in the date range picker - 15 years ago to today, so all accidents
	updateDisplayedDateRange(moment().subtract(15, 'year'), moment());
	
	
	//Upon changes to the date ranges, checks if each accident is after the start date
	//Removes the accident layer and re-adds it with the date filter settings
	$('#reportrange').on('apply.daterangepicker', function (ev, picker) {			
		function dateFilter(feature) {
			if (picker!==undefined) {

				if ((moment(feature.properties.acc_date, 'DD-MMM-YY')) >= moment(new Date(picker.startDate))
					&& (moment(feature.properties.acc_date, 'DD-MMM-YY')) < moment(new Date(picker.endDate))){ 
					return true
				}
				else {
				return false
				}
			}
			}
			
			
			var hasAcc = map.hasLayer(acc);
			var hasAccByType = map.hasLayer(accByType);
			var hasZones = map.hasLayer(zones);
			var hasHeat = map.hasLayer(heat);
	
			map.removeLayer(acc);
			map.removeLayer(accByType);
			map.removeLayer(zones);
			map.removeLayer(heat);
			
			var styleLayer = L.geoJson(null, {
						pointToLayer: function(geoJsonPoint, latlng) {
                        return L.circleMarker(latlng);},
						onEachFeature: onEachFeature,
						style:style,
						filter: dateFilter
			});
			
			var styleLayerByAccType = L.geoJson(null, {
						pointToLayer: function(geoJsonPoint, latlng) {
                        return L.marker(latlng);},
						onEachFeature: onEachFeatureTravelMode,
						style: styleAccidentType,
						filter: dateFilter
	
			});
			//Need to remove the acc layer from the layer control to add in the filtered version
			layerControl.removeLayer(acc);
			layerControl.removeLayer(accByType);
			layerControl.removeLayer(zones);
			layerControl.removeLayer(heat);

			acc = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayer)
			accByType = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayerByAccType);
			
			heat = createHeatmap(map, accPoints, moment(new Date(picker.startDate)), moment(new Date(picker.endDate)));
			
			
			if (hasAcc == true){acc.addTo(map)};
			if (hasAccByType == true){accByType.addTo(map)};
			if (hasZones == true){zones.addTo(map)};
			if (hasHeat == true){heat.addTo(map)};
			
			//Adding back in these layer controls in the correct order
			layerControl.addOverlay(acc, "Accidents");
			layerControl.addOverlay(accByType, "Accidents by Travel Mode");
			layerControl.addOverlay(zones, "Forecast Zones");
			addHeatToOverlays();
			
			barLabels.length=0;
			barChartDates.length=0;
			actSelected = 0;
			monthSelected = 0;
			updateActivityChart();
			processBarChartDates();			
			

	});
	
		
		//Updates the chart upon add of the acc layer
		acc.on("add", updateActivityChart());
		acc.on("add", processBarChartDates());

		
		function delay(time) {
			return new Promise(resolve => setTimeout(resolve, time));
		}
		
		
		async function updateActivityChart() {
			await delay (450);

			//Reduce the array of all activity types to an object with counts of unique activities
			const accCount = barLabels.reduce((allNames, name) => {
				const currCount = allNames[name] ?? 0;
				return {
				...allNames,
				[name]: currCount + 1,
				};
				}, {});
		
		
			//Grab the keys and values from the accCount
			barLabels2=Object.keys(accCount);
			barValues=Object.values(accCount);
			
			
			//Update the bar chart with the labels and values
			barChartCanvas.data.labels = barLabels2;
			barChartCanvas.data.datasets[0].data=barValues;
			
			//Reset the outline of any previously selected activity
			const dataset = barChartCanvas.data.datasets[0];
			dataset.borderWidth = [];
			dataset.borderColor = [];
			for (let i = 0; i < dataset.data.length; i++) {
				dataset.borderWidth[i] = 1;
				dataset.borderColor[i] = "rgba(0, 0, 0, 0.1)";
				}
			
			barChartCanvas.update();
					
		  }

	
	//default fonts for charts
	Chart.defaults.font.family = 'Nanum Gothic';
	Chart.defaults.font.color = '#333';

	//Setting empty arrays to hold activity bar graph data
	const barLabels=[];
	const barData=[];
	
	//Stores whether selections have been made in charts
	var actSelected = 0;
	var monthSelected = 0;
	
	//Properties for activity bar graph
	const canvas = document.getElementById("barChartCanvas");
	const ctx = canvas.getContext('2d');
	const barChartCanvas = new Chart(ctx, {
			type: 'bar',
			data: {
				labels: barLabels,
				datasets: [{
					data: barData,
					borderColor: 'rgba(0, 0, 0, 0.1)',
					borderWidth: 1,
					backgroundColor:'#cdced6'
					
				}]
			},
			options: {
				plugins:{
				legend: false,
				title: {
					display: true,
					text: 'Activity Type',
					position: 'top'
					}
				},
				onClick : evt=> {
					const points = barChartCanvas.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
					if (points.length && monthSelected == 0) {
						actSelected = 1;
						const clickedPoint = points[0];
						const activity = barChartCanvas.data.labels[clickedPoint.index];
						const value = barChartCanvas.data.datasets[clickedPoint.datasetIndex].data[clickedPoint.index];
						const actLabels = barChartCanvas.options.scales.x.ticks;
						const dataset = barChartCanvas.data.datasets[0];
						dataset.borderWidth = [];
						dataset.borderColor = [];
						for (let i = 0; i < dataset.data.length; i++) {
							if (clickedPoint.index == i) {
								dataset.borderWidth[i] = 4;
								dataset.borderColor[i] = "black";
							} else {
								dataset.borderWidth[i] = 1;
								dataset.borderColor[i] = "rgba(0, 0, 0, 0.1)";
							}
						}
						barChartCanvas.update();
						const startDate = moment(new Date($('#reportrange').data('daterangepicker').startDate));
						const endDate = moment(new Date($('#reportrange').data('daterangepicker').endDate));

						function activityFilter(feature){
							if (feature.properties.acc_activity == activity && (moment(feature.properties.acc_date, 'DD-MMM-YY')) >= startDate && (moment(feature.properties.acc_date, 'DD-MMM-YY')) < endDate)
							{
								return true
								}
							else {
								return false
								}
						}
						
						//Checks which layers are toggled on in map before removing them
						var hasAcc = map.hasLayer(acc);
						var hasAccByType = map.hasLayer(accByType);
						var hasZones = map.hasLayer(zones);
						var hasHeat = map.hasLayer(heat);
			
			
						map.removeLayer(acc);
						map.removeLayer(accByType);
						map.removeLayer(zones);
						map.removeLayer(heat);
		
						var styleLayer = L.geoJson(null, {
							pointToLayer: function(geoJsonPoint, latlng) {
							return L.circleMarker(latlng);},
							onEachFeature: onEachFeature,
							style:style,
							filter: activityFilter
						});
						var styleLayerByAccType = L.geoJson(null, {
							pointToLayer: function(geoJsonPoint, latlng) {
							return L.marker(latlng);},
							onEachFeature: onEachFeatureTravelMode,
							style: styleAccidentType,
							filter: activityFilter
						
						});
						
						layerControl.removeLayer(acc);
						layerControl.removeLayer(accByType);
						layerControl.removeLayer(zones);
						layerControl.removeLayer(heat);

						acc = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayer)
						accByType = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayerByAccType);
						
						heat = createHeatmapActivity(map, accPoints, activity, startDate, endDate);
						
						//Adds back in layers that were last checked on
						if (hasAcc == true){acc.addTo(map)};
						if (hasAccByType == true){accByType.addTo(map)};
						if (hasZones == true){zones.addTo(map)};
						if (hasHeat == true){heat.addTo(map)};
						
						layerControl.addOverlay(acc, "Accidents");
						layerControl.addOverlay(accByType, "Accidents by Travel Mode");
						layerControl.addOverlay(zones, "Forecast Zones");
						addHeatToOverlays();
						
						barChartDates.length=0;
						processBarChartDates();
					
				  }},

				scales: {
				x: {
					title:{
						text: 'Activity Type',
						display: false
					}

					},
					
				y:{
					title:{
						text: 'Accidents',
						display: true
					},
					ticks: {
						callback: function(value) {if (value % 1 === 0) {return value;}}
					}
				}
			}
		}});
	
	let barChart = new Chart('bar-chart', {
		type: 'bar',
		options: {
			plugins: {
				title: {
					display: true,
					text: 'Month',
					padding: {
						top: 10,
						bottom: 10
                	}
				},
				legend: false
			},
			maintainAspectRatio: false,
			onClick : evt=> {
					const points = barChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true);
					if (points.length && actSelected == 0) {
						monthSelected = 1;
						const clickedPoint = points[0];
						const month = barChart.data.labels[clickedPoint.index];
						const value = barChart.data.datasets[clickedPoint.datasetIndex].data[clickedPoint.index];
						const monthLabels = barChart.options.scales.x.ticks;
						const dataset = barChart.data.datasets[0];
						dataset.borderWidth = [];
						dataset.borderColor = [];
						for (let i = 0; i < dataset.data.length; i++) {
							if (clickedPoint.index == i) {
								dataset.borderWidth[i] = 4;
								dataset.borderColor[i] = "black";
							} else {
								dataset.borderWidth[i] = 1;
								dataset.borderColor[i] = "rgba(0, 0, 0, 0.1)";
							}
						}
						barChart.update();
						const startDate = moment(new Date($('#reportrange').data('daterangepicker').startDate));
						const endDate = moment(new Date($('#reportrange').data('daterangepicker').endDate));

						function monthFilter(feature){
							if (moment(feature.properties.acc_date, ["DD-MMM-YY"]).format("MMM") == month && (moment(feature.properties.acc_date, 'DD-MMM-YY')) >= startDate && (moment(feature.properties.acc_date, 'DD-MMM-YY')) < endDate)
							{
								return true
								}
							else {
								return false
								}
						}
						
						//Checks which layers are toggled on in map before removing them
						var hasAcc = map.hasLayer(acc);
						var hasAccByType = map.hasLayer(accByType);
						var hasZones = map.hasLayer(zones);
						var hasHeat = map.hasLayer(heat);
			
			
						map.removeLayer(acc);
						map.removeLayer(accByType);
						map.removeLayer(zones);
						map.removeLayer(heat);
		
						var styleLayer = L.geoJson(null, {
							pointToLayer: function(geoJsonPoint, latlng) {
							return L.circleMarker(latlng);},
							onEachFeature: onEachFeature,
							style:style,
							filter: monthFilter
						});
						var styleLayerByAccType = L.geoJson(null, {
							pointToLayer: function(geoJsonPoint, latlng) {
							return L.marker(latlng);},
							onEachFeature: onEachFeatureTravelMode,
							style: styleAccidentType,
							filter: monthFilter
						
						});
						
						layerControl.removeLayer(acc);
						layerControl.removeLayer(accByType);
						layerControl.removeLayer(zones);
						layerControl.removeLayer(heat);

						acc = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayer)
						accByType = omnivore.csv('https://raw.githubusercontent.com/dseidlCoMtn/caic_accident/main/CO_Accidents.csv', null, styleLayerByAccType);
						
						heat = createHeatmapMonth(map, accPoints, month, startDate, endDate);
						
						//Adds back in layers that were last checked on
						if (hasAcc == true){acc.addTo(map)};
						if (hasAccByType == true){accByType.addTo(map)};
						if (hasZones == true){zones.addTo(map)};
						if (hasHeat == true){heat.addTo(map)};
						
						layerControl.addOverlay(acc, "Accidents");
						layerControl.addOverlay(accByType, "Accidents by Travel Mode");
						layerControl.addOverlay(zones, "Forecast Zones");
						addHeatToOverlays();
						
						barLabels.length=0;
						updateActivityChart();
					
				  }},
			scales: {
				x: {
					title:{
						text: 'Month',
						display: false
						}
				},
						
				y: {
					title:{
						text: 'Accidents',
						display: true
						},
					ticks: {callback: function(value) {if (value % 1 === 0) {return value;}}}
				}				
					
			}
		},
		data: {
			datasets: [
				{
				backgroundColor:'#cdced6'
        }
			]
		}
		
	});

	let barChartDates = [];

	async function processBarChartDates() {
		await delay (450);
		/* console.log("barChartDates: ", barChartDates); */
		/* Reduce the array of all accident dates  to an object with counts of unique months */
		let dateData = barChartDates.reduce((allDates, month) => {
				const currentCount = allDates[month] ?? 0;
				return {
				...allDates,
				[month]: currentCount + 1,
				};
		}, {});


		/* Convert the dates and counts to array and sort by month */
		let dateDataArr=Object.entries(dateData);
		sortByMonth(dateDataArr);
		function sortByMonth(arr) {
			var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
			arr.sort(function(a, b){
			return months.indexOf(a[0]) - months.indexOf(b[0]);
		});
		}
		let barChartKeys = Object.keys(Object.fromEntries(dateDataArr));
		barChartValues=Object.values(Object.fromEntries(dateDataArr));
		
		/* // Update the bar chart with the labels and values */
		barChart.data.labels = barChartKeys;
		barChart.data.datasets[0].data=barChartValues;
		
		// Reset highlighting of previously selected month
		const dataset = barChart.data.datasets[0];
			dataset.borderWidth = [];
			dataset.borderColor = [];
			for (let i = 0; i < dataset.data.length; i++) {
				dataset.borderWidth[i] = 1;
				dataset.borderColor[i] = "rgba(0, 0, 0, 0.1)";
				}
			
		barChart.update();
	}

	L.control.scale().addTo(map);

	//legend for all layers on
	var legendAll = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendAll.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>D Scale, 1 to 5</b></br>";
		div.innerHTML += '<i style="background: rgba(255, 255, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 232, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 208, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 184, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 159, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 132, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 103, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 69, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 0, 0)"></i><span></span><br><br>';
 		div.innerHTML += "<b>R Scale Circle Size, 1 to 5</b></br>";
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 10px; height: 10px; margin-right: 2px; margin-top: 8px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 12px; height: 12px; margin-right: 2px; margin-top: 6px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 14px; height: 14px; margin-right: 2px; margin-top: 4px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 16px; height: 16px; margin-right: 2px; margin-top: 2px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 18px; height: 18px"></i><span></span><br><br>';
		div.innerHTML += "<b>Travel Mode</b></br>";
		div.innerHTML += '<img src="images/ski_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Ski/Snowboard</br>";
		div.innerHTML += '<img src="images/snowmobile_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowmobile</br>";
		div.innerHTML += '<img src="images/foot_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Hiker</br>";
		div.innerHTML += '<img src="images/snowshoe_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowshoer<br>";
		div.innerHTML += '<img src="images/other_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Other<br><br>";
		div.innerHTML += "<b>Heatmap, Least to Most Dense</b></br>";
		div.innerHTML += '<i style="background: cyan"></i><span></span>';
		div.innerHTML += '<i style="background: blue"></i><span></span>';
		div.innerHTML += '<i style="background: purple" ></i><span></span>';

		return div;
	};
	//legendAll.addTo(map);

	//legend for just Accidents layer
	var legendAcc = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendAcc.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>D Scale, 1 to 5</b></br>";
		div.innerHTML += '<i style="background: rgba(255, 255, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 232, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 208, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 184, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 159, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 132, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 103, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 69, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 0, 0)"></i><span></span><br><br>';
 		div.innerHTML += "<b>R Scale Circle Size, 1 to 5</b></br>";
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 10px; height: 10px; margin-right: 2px; margin-top: 8px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 12px; height: 12px; margin-right: 2px; margin-top: 6px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 14px; height: 14px; margin-right: 2px; margin-top: 4px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 16px; height: 16px; margin-right: 2px; margin-top: 2px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 18px; height: 18px"></i><span></span>';

		return div;
	};
	//legendAcc.addTo(map);

	//legend for Accident by Travel Mode layer
	var legendAccByType = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendAccByType.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>Travel Mode</b></br>";
		div.innerHTML += '<img src="images/ski_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Ski/Snowboard</br>";
		div.innerHTML += '<img src="images/snowmobile_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowmobile</br>";
		div.innerHTML += '<img src="images/foot_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Hiker</br>";
		div.innerHTML += '<img src="images/snowshoe_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowshoer<br>";
		div.innerHTML += '<img src="images/other_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Other";

		return div;
	};
	//legendAccByType.addTo(map);

	//legend for heatmap layer
	var legendHeatmap = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendHeatmap.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>Heatmap, Least to Most Dense</b></br>";
		div.innerHTML += '<i style="background: cyan"></i><span></span>';
		div.innerHTML += '<i style="background: blue"></i><span></span>';
		div.innerHTML += '<i style="background: purple" ></i><span></span>';

		return div;
	};
	//legendHeatmap.addTo(map);

	var legendAccAndAccByType = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendAccAndAccByType.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>D Scale, 1 to 5</b></br>";
		div.innerHTML += '<i style="background: rgba(255, 255, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 232, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 208, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 184, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 159, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 132, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 103, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 69, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 0, 0)"></i><span></span><br><br>';
 		div.innerHTML += "<b>R Scale Circle Size, 1 to 5</b></br>";
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 10px; height: 10px; margin-right: 2px; margin-top: 8px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 12px; height: 12px; margin-right: 2px; margin-top: 6px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 14px; height: 14px; margin-right: 2px; margin-top: 4px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 16px; height: 16px; margin-right: 2px; margin-top: 2px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 18px; height: 18px"></i><span></span><br><br>';
		div.innerHTML += "<b>Travel Mode</b></br>";
		div.innerHTML += '<img src="images/ski_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Ski/Snowboard</br>";
		div.innerHTML += '<img src="images/snowmobile_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowmobile</br>";
		div.innerHTML += '<img src="images/foot_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Hiker</br>";
		div.innerHTML += '<img src="images/snowshoe_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowshoer<br>";
		div.innerHTML += '<img src="images/other_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Other";

		return div;
	};
	//legendAccAndAccByType.addTo(map);

	var legendAccAndHeatmap = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendAccAndHeatmap.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>D Scale, 1 to 5</b></br>";
		div.innerHTML += '<i style="background: rgba(255, 255, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 232, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 208, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 184, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 159, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 132, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 103, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 69, 0)"></i><span></span>';
		div.innerHTML += '<i style="background: rgba(255, 0, 0)"></i><span></span><br><br>';
 		div.innerHTML += "<b>R Scale Circle Size, 1 to 5</b></br>";
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 10px; height: 10px; margin-right: 2px; margin-top: 8px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 12px; height: 12px; margin-right: 2px; margin-top: 6px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 14px; height: 14px; margin-right: 2px; margin-top: 4px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 16px; height: 16px; margin-right: 2px; margin-top: 2px"></i><span></span>';
		div.innerHTML += '<i style="border-radius: 50%; border-width: 1px; border: solid grey; width: 18px; height: 18px"></i><span></span><br><br>';
		div.innerHTML += "<b>Heatmap, Least to Most Dense</b></br>";
		div.innerHTML += '<i style="background: cyan"></i><span></span>';
		div.innerHTML += '<i style="background: blue"></i><span></span>';
		div.innerHTML += '<i style="background: purple" ></i><span></span>';

		return div;
	};
	//legendAccAndHeatmap.addTo(map);

	var legendAccByTypeAndHeatmap = L.control({ position: "bottomleft", orientation: 'horizontal'});
	legendAccByTypeAndHeatmap.onAdd = function(map) {
	var div = L.DomUtil.create("div", "info legend");
		div.innerHTML += "<b>Travel Mode</b></br>";
		div.innerHTML += '<img src="images/ski_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Ski/Snowboard</br>";
		div.innerHTML += '<img src="images/snowmobile_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowmobile</br>";
		div.innerHTML += '<img src="images/foot_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Hiker</br>";
		div.innerHTML += '<img src="images/snowshoe_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Snowshoer<br>";
		div.innerHTML += '<img src="images/other_icon.svg" style="height: 22px; width: 22px"></img><span></span>' + "  Other<br><br>";
		div.innerHTML += "<b>Heatmap, Least to Most Dense</b></br>";
		div.innerHTML += '<i style="background: cyan"></i><span></span>';
		div.innerHTML += '<i style="background: blue"></i><span></span>';
		div.innerHTML += '<i style="background: purple" ></i><span></span>';

		return div;
	};
	legendAccByTypeAndHeatmap.addTo(map);


</script>

</body>
</html>
